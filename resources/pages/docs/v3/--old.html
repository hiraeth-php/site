		## Routed Templates {: #routed-templates}

		Routed templates are similar to static templates in that the request is short circuited and goes directly to loading a template (not through an action).  Unlike static templates, however, routed templates add the ability to have some variability in the template location (that includes the extension).  The `hiraeth/routing`{: .package} package will attempt to route directly to a template when the target starts with `@'.

		```toml
		routes = map(application.route) {
			/schema/{version}		@pages/schema/{version}.json		["GET"]
		}
		```

		In the above example we provide a route to multiple JSON schema versions.  This allows us to route to a `.json` file rather than the default `.html`.  Similarly, we can access the parameter inside the template:

		```json
		{
			"version": {% verbatim %}{{ route.parameters.version }}{% endverbatim %}
		}
		```

		{: .note}
		Note, that unlike static templates, the parameters are now carried on the `route`.

		## Actions {: #actions}

		Actions are PHP classes which are invoked to perform control logic.  You may already be familiar with the concept, but only know them as "controllers."  While Hiraeth supports more traditional controller paradigms, it strongly encourages the use of "single action controllers" or simply "actions" to reduce the complexity that may occur in monolithic controller classes.  Shared behaviors and logic are generally better served by traits or abstraction.

		{: .note}
		An action that is routed to will always supersede static templates, as the template middleware actually only handles lookups on the response flow and only in the event the response is a `404`.  Accordingly, static templates will act as a fallback for any route that cannot resolve an action or where an action explicitly returns a `404`.















		It is often the case that you may return the same content with different status codes.  One way to do this is to set your template to a variable:

		```php
		$template = $this->template('@pages/organization/detail.html');

		if ($this->request->getMethod() == 'POST') {
			try {
				// Update the record
			} catch (Exception $e) {
				return $this->response(400, $template);
			}
		}

		return $this->response(200, $template);
		```

		However, another approach is to always return the template directly instead of a response and to use the `init()` method to initialize the resolver's response:

		```php
		if ($this->request->getMethod() == 'POST') {
			try {
				// Update the record
			} catch (Exception $e) {
				$this->init(400);
			}
		}

		return $this->template('@pages/organization/detail.html', $data);
		```

		The response is always initialized at `200`, so you only need to call it to change the value.


		### Objects (JSON) {: #objects }

		```php
		return $this->object([
			'title' => 'A nice JSON response',
			'body'  => 'Nothing to see here'
		])
		```

		The default status code on an object is `200`, and its content type will be `application/json`.  If you need to change these you can

		```php
		return $this->response(201, $this->object($new_entity));
		```

		Now that you've got your action in place, you're going to need to add a route in order to map a URL to your action.
