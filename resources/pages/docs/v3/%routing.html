{% extends '@layouts/docs-3.0.html' | proxy('header', 'content') %}

{% set title = "Routing" %}

{% block header %}
	<x::title text="{{ title }}" />

	<x:docs:header>
		<h1>{{ title }}</h1>
	</x:docs:header>
{% endblock %}

{% block content %}
	{% apply markdown %}
		{: .note}
		This document assumes you've installed `hiraeth/bootstrap`{: .package} or a combination of an HTTP (`hiraeth/diactoros`{: .package}) provider and `hiraeth/fastroute`{: .package}.

		Hiraeth's bootstrap uses [FastRoute](https://github.com/nikic/FastRoute) with a custom "transformation layer" on top to provide some much needed missing features like:

		- [Parameter Pattern Aliases](#patterns)
		- [Parameter Transformers](#transformers)
		- [Route Masking](#masking)

		## Adding Routes {: #adding-routes}

		The main route map is located in `config/routes.jin`{: .config}.  Routes can be added to the `routes` map, a one-or-more tab separated values list defining the route, target, and methods for which the route applies.  The target on a route, by default, can be either a templates or actions.  Unlike pages, routes allow you finer control in that you can define distinct entry points depending on the method, load templates other than `.html`, and make use of pattern aliases, transformers, and other advanced features.  To change this:

		1. We'll rename our template to exclude the `@` on the file name portion.  The `@` signifies that a template is directly available as a page, but since we're now going to route directly to it, it can simply be `resources/pages/words/get.html`{: .html}.
		2. We'll remove our `resources/pages/words/~matchers.jin`{: .config}.  The router will now handle all URL parameterization.
		3. Finally, we'll add the route in `config/routes.jin`{: .config}:

		```toml
		[routing]
			routes = map(application.route) {
				/words/{word}	@pages/words/get.html	["GET"]
			}
		```

		{: .note}
		By adding this route, we explicitly make it available only on a `GET` request.  If you need to match all possible methods, you can use `["*"]` as the methods value, or simply add additional methods to the array.

		## Prefixes {: #prefixes}

		If you need to move all your routes under a specific path, you can use `prefix` to define the leading URL segment for all the routes in the group.  Multiple groups can have the same prefix as well, so feel free to break up your route collections in more specific groups if you like.  For example we could update our routing config as follows:

		```toml
		[routing]
			prefix = /words

			routes = map(application.route) {
				/{word}		@pages/words/get.html	["GET"]
			}
		```

		## Parameters {: #parameters}

		Parameters in routing provide much more advanced features than what's available in matcher configuration.  The basic style of a route parameter has already been shown, however, it's also possible to add custom pattern matching as well as transformers.

		In the case of words, we may want to make sure that our words are always lowercase to enforce canonical URLs.

		### Patterns {: #patterns}

		To match parameters more precisely, you can follow the parameter name in the route with a `:` and add a RegEx or a pattern alias (a simple character or string used as a shorthand).  Let's update our route and change:

		1. The name of the parameter to be clearer
		2. The pattern that it must match

		```toml
			routes = map(application.route) {
				/{record:word}	@pages/words/get.html	["GET"]
			}
		```

		Given the above, the parameter `record` will now be constrained to matching the `word` pattern.  To add our own pattern, we can add a `[fastroute]` section to any configuration collection and set a `patterns` key equal to an object mapping the pattern alias (the key) to the regular expression (the value).  An example date pattern might look like the following:

		```toml
		[fastroute]

			patterns = {
				"word": "[a-z]+"
			}
		```

		{: .note}
		Don't forget to update your action's `__invoke()` method arguments as well as anywhere `{% verbatim %}{{ parameters.word }}{% endverbatim %}` was used in the templates.  In these contrived examples we're choosing names for temporary demonstration purposes, but in most cases where you know how you're going to handle requests up front, this is not an issue.

		### Transformers {: #transformers}

		Transformers are a way to convert parameters to native PHP types before they're passed to your actions.  Since URLs are ultimately only string, if you want, for example, to convert your parameter to a database record before being injected into the action, you can use a transformer.

		In order to create a transformer we create a new class that implements the `Hiraeth\FastRoute\Transformer`{: .interface} interface.  This interface requires two methods:

		| Method       | Description
		|--------------|--------------------------------------------
		| `fromUrl()`  | Converts the paramter from the URL form (string) to the native PHP type
		| `toUrl()`    | Converts the parameter from the native PHP type (mixed) to the URL form (string)

		While we've not gone over databases yet, let's take a look at how that might hypothetically look by converting our `record` parameter, into an actual record:

		```php
		namespace Words;

		class Transformer implements Hiraeth\FastRoute\Transformer
		{
			public function __construct(
				public Repository $words
			) {}

			public function fromUrl($name, $value, array $context = array())
			{
				return $this->words->find($value);
			}

			public function toUrl($name, $value, array $context = array()): string
			{
				if (!$value instanceof Entity) {
					throw new \InvalidArgumentException(sprintf(
						'Parameter "%s" must be a valid %s object',
						$name,
						Entity::class
					));
				}

				return $word->getId();
			}
		}
		```

		We then register the transformer based on the same pattern name it matches.

		```toml
		[fastroute]

			transformers = {
				"word": "Words\Transformer"
			}
		```

		After the addition of both the pattern and our transormer, our new action will look something like this:

		```php
		namespace Words;

		class Get extends \AbstractAction
		{
			public function __invoke(Entity $record)
			{
				$template = sprintf('@pages/words/%s.html', $record->getId());
				$data     = [
					'record' => $record
				];

				if (!$this->templates->has($template)) {
					return $this->response(
						404,
						$this->template('@pages/words/404.html', $data)
					);
				}

				return $data;
			}
		}
		```

		## Route Generation

		Whenever you generate link or url to a route you should be using an instance of a `Hiraeth\Routing\UrlGenerator` to account for various transformations.  While it's possible to typehint this and have it injected directly into your classes, there are existing helpers for both actions and inside Twig.

		From an Action:

		```php
		$this->route('/words/{record:word}', ['record' => $record]);
		```

		From inside a Twig template:

		```twig{% verbatim %}
		{{ route('/words/{record:word}', {record: record}) }}
		{% endverbatim %}```

		This will allow you to tranform the native objects back to their parameter's string representation.  Additionally, it will allow you to make use of other features like the `hiraeth/http`{: .package} package's `BASE_URL` option, and route masking, which we'll go over now:

		{: .note}
		The `redirect()` method available on classes extending `AbstractAction`{: .class} will proxy this method automatically.

		### Route Masking {: #masking}

		On occasion, you may be working in a code base that serves multiple clients with very particular branding or needs.  Route masking is a form of transparent URL rewriting that perform a simple search and replace.  Accordingly, it's primarily intended only for static segments of the URL.

		Let's say you sold your dictionary app to Webster, but they want to change the `/words/` URL to `terms` without changing the internal domain language:

		```toml
		[fastroute]

			masks = {
				"/words/": "/terms/"
			}
		```

		Now an incoming request to say `/terms/hiraeth` will be rewritten as `/words/hiraeth` and will continue matching the routes for `/words/...`, similarly when you use the URL generator or the associated `route()` helpers, the URL produced will be translated back.

		## Routing to Actions

		Up to this point, we have maintained a strictly view-first approach to our hypothetical application development.  While we believe there are [many benefits to this approach](./view-first), inevitably old habits die hard and someone wants to go the more "traditional" MVC route (no pun intended).

		Routing to an action is quite simple.  Simply replace the template path with the class name of the action:

		```toml
			/words/{id:word}	Words\Get	["GET"]
		```

		Critically, however, if you want to continue returning templates as a response (i.e. if you're not just add/writing an API), you'll need to get a better understanding of responders.

		----

		[Learn About Responders](./responders){: .action}
	{% endapply %}

	{% include '@layouts/chat.html' %}
{% endblock %}
